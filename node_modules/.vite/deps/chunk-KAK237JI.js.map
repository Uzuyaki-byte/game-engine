{
  "version": 3,
  "sources": ["../../../dev/core/src/Maths/math.functions.ts", "../../../dev/core/src/Shaders/gpuTransform.vertex.ts", "../../../dev/core/src/Shaders/gpuTransform.fragment.ts", "../../../dev/core/src/Culling/Helper/transformFeedbackBoundingHelper.ts"],
  "sourcesContent": ["import type { FloatArray, Nullable, IndicesArray } from \"../types\";\r\nimport type { Vector2 } from \"./math.vector\";\r\nimport { Vector3 } from \"./math.vector\";\r\nimport { nativeOverride } from \"../Misc/decorators\";\r\n\r\n// This helper class is only here so we can apply the nativeOverride decorator to functions.\r\nclass MathHelpers {\r\n    @nativeOverride.filter((...[positions, indices]: Parameters<typeof MathHelpers.extractMinAndMaxIndexed>) => !Array.isArray(positions) && !Array.isArray(indices))\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static extractMinAndMaxIndexed(positions: FloatArray, indices: IndicesArray, indexStart: number, indexCount: number, minimum: Vector3, maximum: Vector3): void {\r\n        for (let index = indexStart; index < indexStart + indexCount; index++) {\r\n            const offset = indices[index] * 3;\r\n            const x = positions[offset];\r\n            const y = positions[offset + 1];\r\n            const z = positions[offset + 2];\r\n            minimum.minimizeInPlaceFromFloats(x, y, z);\r\n            maximum.maximizeInPlaceFromFloats(x, y, z);\r\n        }\r\n    }\r\n\r\n    @nativeOverride.filter((...[positions]: Parameters<typeof MathHelpers.extractMinAndMax>) => !Array.isArray(positions))\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static extractMinAndMax(positions: FloatArray, start: number, count: number, stride: number, minimum: Vector3, maximum: Vector3): void {\r\n        for (let index = start, offset = start * stride; index < start + count; index++, offset += stride) {\r\n            const x = positions[offset];\r\n            const y = positions[offset + 1];\r\n            const z = positions[offset + 2];\r\n            minimum.minimizeInPlaceFromFloats(x, y, z);\r\n            maximum.maximizeInPlaceFromFloats(x, y, z);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Extracts minimum and maximum values from a list of indexed positions\r\n * @param positions defines the positions to use\r\n * @param indices defines the indices to the positions\r\n * @param indexStart defines the start index\r\n * @param indexCount defines the end index\r\n * @param bias defines bias value to add to the result\r\n * @returns minimum and maximum values\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function extractMinAndMaxIndexed(\r\n    positions: FloatArray,\r\n    indices: IndicesArray,\r\n    indexStart: number,\r\n    indexCount: number,\r\n    bias: Nullable<Vector2> = null\r\n): { minimum: Vector3; maximum: Vector3 } {\r\n    const minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n    const maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n    MathHelpers.extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, minimum, maximum);\r\n\r\n    if (bias) {\r\n        minimum.x -= minimum.x * bias.x + bias.y;\r\n        minimum.y -= minimum.y * bias.x + bias.y;\r\n        minimum.z -= minimum.z * bias.x + bias.y;\r\n        maximum.x += maximum.x * bias.x + bias.y;\r\n        maximum.y += maximum.y * bias.x + bias.y;\r\n        maximum.z += maximum.z * bias.x + bias.y;\r\n    }\r\n\r\n    return {\r\n        minimum: minimum,\r\n        maximum: maximum,\r\n    };\r\n}\r\n\r\n/**\r\n * Extracts minimum and maximum values from a list of positions\r\n * @param positions defines the positions to use\r\n * @param start defines the start index in the positions array\r\n * @param count defines the number of positions to handle\r\n * @param bias defines bias value to add to the result\r\n * @param stride defines the stride size to use (distance between two positions in the positions array)\r\n * @returns minimum and maximum values\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function extractMinAndMax(positions: FloatArray, start: number, count: number, bias: Nullable<Vector2> = null, stride?: number): { minimum: Vector3; maximum: Vector3 } {\r\n    const minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n    const maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n    if (!stride) {\r\n        stride = 3;\r\n    }\r\n\r\n    MathHelpers.extractMinAndMax(positions, start, count, stride, minimum, maximum);\r\n\r\n    if (bias) {\r\n        minimum.x -= minimum.x * bias.x + bias.y;\r\n        minimum.y -= minimum.y * bias.x + bias.y;\r\n        minimum.z -= minimum.z * bias.x + bias.y;\r\n        maximum.x += maximum.x * bias.x + bias.y;\r\n        maximum.y += maximum.y * bias.x + bias.y;\r\n        maximum.z += maximum.z * bias.x + bias.y;\r\n    }\r\n\r\n    return {\r\n        minimum: minimum,\r\n        maximum: maximum,\r\n    };\r\n}\r\n\r\n/**\r\n * Flip flipped faces\r\n * @param positions defines the positions to use\r\n * @param indices defines the indices to use and update\r\n */\r\nexport function FixFlippedFaces(positions: FloatArray, indices: IndicesArray): void {\r\n    const boundingInfo = extractMinAndMax(positions, 0, positions.length / 3);\r\n\r\n    const inside = boundingInfo.maximum.subtract(boundingInfo.minimum).scale(0.5).add(boundingInfo.minimum);\r\n    const tmpVectorA = new Vector3();\r\n    const tmpVectorB = new Vector3();\r\n    const tmpVectorC = new Vector3();\r\n    const tmpVectorAB = new Vector3();\r\n    const tmpVectorAC = new Vector3();\r\n    const tmpVectorNormal = new Vector3();\r\n    const tmpVectorAvgNormal = new Vector3();\r\n\r\n    // Clean indices\r\n    for (let index = 0; index < indices.length; index += 3) {\r\n        const a = indices[index];\r\n        const b = indices[index + 1];\r\n        const c = indices[index + 2];\r\n\r\n        // Evaluate face normal\r\n        tmpVectorA.fromArray(positions, a * 3);\r\n        tmpVectorB.fromArray(positions, b * 3);\r\n        tmpVectorC.fromArray(positions, c * 3);\r\n\r\n        tmpVectorB.subtractToRef(tmpVectorA, tmpVectorAB);\r\n        tmpVectorC.subtractToRef(tmpVectorA, tmpVectorAC);\r\n\r\n        Vector3.CrossToRef(tmpVectorAB, tmpVectorAC, tmpVectorNormal);\r\n\r\n        tmpVectorNormal.normalize();\r\n\r\n        // Calculate normal from face center to the inside of the geometry\r\n        const avgX = tmpVectorA.x + tmpVectorB.x + tmpVectorC.x;\r\n        const avgY = tmpVectorA.y + tmpVectorB.y + tmpVectorC.y;\r\n        const avgZ = tmpVectorA.z + tmpVectorB.z + tmpVectorC.z;\r\n\r\n        tmpVectorAvgNormal.set(avgX / 3, avgY / 3, avgZ / 3);\r\n        tmpVectorAvgNormal.subtractInPlace(inside);\r\n        tmpVectorAvgNormal.normalize();\r\n\r\n        if (Vector3.Dot(tmpVectorNormal, tmpVectorAvgNormal) >= 0) {\r\n            // Flip!\r\n            indices[index] = c;\r\n            indices[index + 2] = a;\r\n        }\r\n    }\r\n}\r\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal\";\nimport \"./ShadersInclude/morphTargetsVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\n\nconst name = \"gpuTransformVertexShader\";\nconst shader = `attribute vec3 position;\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\nout vec3 outPosition;const mat4 identity=mat4(\nvec4(1.0,0.0,0.0,0.0),\nvec4(0.0,1.0,0.0,0.0),\nvec4(0.0,0.0,1.0,0.0),\nvec4(0.0,0.0,0.0,1.0)\n);void main(void) {vec3 positionUpdated=position;\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\nmat4 finalWorld=identity;\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);outPosition=worldPos.xyz;}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const gpuTransformVertexShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"gpuTransformPixelShader\";\nconst shader = `#version 300 es\nvoid main() {discard;}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const gpuTransformPixelShader = { name, shader };\n", "import type { Effect } from \"core/Materials/effect\";\r\nimport type { ThinEngine } from \"core/Engines/thinEngine\";\r\nimport { VertexBuffer, Buffer } from \"core/Buffers/buffer\";\r\nimport type { Engine } from \"core/Engines/engine\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindMorphTargetParameters,\r\n    PrepareAttributesForBakedVertexAnimation,\r\n    PrepareDefinesAndAttributesForMorphTargets,\r\n} from \"core/Materials/materialHelper.functions\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { IBoundingInfoHelperPlatform } from \"./IBoundingInfoHelperPlatform\";\r\nimport { extractMinAndMax } from \"core/Maths/math.functions\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\n\r\nimport \"../../Shaders/gpuTransform.vertex\";\r\nimport \"../../Shaders/gpuTransform.fragment\";\r\n\r\n/** @internal */\r\nexport class TransformFeedbackBoundingHelper implements IBoundingInfoHelperPlatform {\r\n    private static _Min = new Vector3();\r\n    private static _Max = new Vector3();\r\n\r\n    private _engine: Nullable<ThinEngine>;\r\n    private _buffers: { [key: number]: Buffer } = {};\r\n    private _effects: { [key: string]: Effect } = {};\r\n    private _meshList: AbstractMesh[];\r\n    private _meshListCounter = 0;\r\n\r\n    /**\r\n     * Creates a new TransformFeedbackBoundingHelper\r\n     * @param engine defines the engine to use\r\n     */\r\n    constructor(engine: ThinEngine) {\r\n        this._engine = engine;\r\n    }\r\n\r\n    /** @internal */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public processAsync(meshes: AbstractMesh | AbstractMesh[]): Promise<void> {\r\n        if (!Array.isArray(meshes)) {\r\n            meshes = [meshes];\r\n        }\r\n\r\n        this._meshListCounter = 0;\r\n\r\n        this._processMeshList(meshes);\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    private _processMeshList(meshes: AbstractMesh[]) {\r\n        const parallelShaderCompile = this._engine!.getCaps().parallelShaderCompile;\r\n\r\n        this._engine!.getCaps().parallelShaderCompile = undefined;\r\n\r\n        for (let i = 0; i < meshes.length; ++i) {\r\n            const mesh = meshes[i];\r\n            const vertexCount = mesh.getTotalVertices();\r\n\r\n            if (vertexCount === 0 || !(mesh as Mesh).getVertexBuffer || !(mesh as Mesh).getVertexBuffer(VertexBuffer.PositionKind)) {\r\n                continue;\r\n            }\r\n\r\n            // Get correct effect\r\n            let computeEffect: Effect;\r\n            const defines: string[] = [];\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            // Bones\r\n            if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n                attribs.push(VertexBuffer.MatricesIndicesKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsKind);\r\n                if (mesh.numBoneInfluencers > 4) {\r\n                    attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                    attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n                }\r\n                defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n                defines.push(\"#define BONETEXTURE \" + mesh.skeleton.isUsingTextureForMatrices);\r\n                defines.push(\"#define BonesPerMesh \" + (mesh.skeleton.bones.length + 1));\r\n            } else {\r\n                defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n            }\r\n\r\n            // Morph\r\n            const numMorphInfluencers = mesh.morphTargetManager\r\n                ? PrepareDefinesAndAttributesForMorphTargets(\r\n                      mesh.morphTargetManager,\r\n                      defines,\r\n                      attribs,\r\n                      mesh,\r\n                      true, // usePositionMorph\r\n                      false, // useNormalMorph\r\n                      false, // useTangentMorph\r\n                      false, // useUVMorph\r\n                      false, // useUV2Morph\r\n                      false // useColorMorph\r\n                  )\r\n                : 0;\r\n\r\n            // Baked Vertex Animation\r\n            const bvaManager = (<Mesh>mesh).bakedVertexAnimationManager;\r\n            if (bvaManager && bvaManager.isEnabled) {\r\n                defines.push(\"#define BAKED_VERTEX_ANIMATION_TEXTURE\");\r\n                PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);\r\n            }\r\n\r\n            const join = defines.join(\"\\n\");\r\n            if (!this._effects[join]) {\r\n                const uniforms = [\r\n                    \"boneTextureWidth\",\r\n                    \"mBones\",\r\n                    \"morphTargetInfluences\",\r\n                    \"morphTargetCount\",\r\n                    \"morphTargetTextureInfo\",\r\n                    \"morphTargetTextureIndices\",\r\n                    \"bakedVertexAnimationSettings\",\r\n                    \"bakedVertexAnimationTextureSizeInverted\",\r\n                    \"bakedVertexAnimationTime\",\r\n                ];\r\n                const samplers = [\"boneSampler\", \"morphTargets\", \"bakedVertexAnimationTexture\"];\r\n\r\n                const computeEffectOptions = {\r\n                    attributes: attribs,\r\n                    uniformsNames: uniforms,\r\n                    uniformBuffersNames: [],\r\n                    samplers: samplers,\r\n                    defines: join,\r\n                    fallbacks: null,\r\n                    onCompiled: null,\r\n                    onError: null,\r\n                    indexParameters: { maxSimultaneousMorphTargets: numMorphInfluencers },\r\n                    maxSimultaneousLights: 0,\r\n                    transformFeedbackVaryings: [\"outPosition\"],\r\n                };\r\n                computeEffect = this._engine!.createEffect(\"gpuTransform\", computeEffectOptions, this._engine!);\r\n                this._effects[join] = computeEffect;\r\n            } else {\r\n                computeEffect = this._effects[join];\r\n            }\r\n\r\n            this._compute(mesh, computeEffect);\r\n        }\r\n\r\n        this._engine!.getCaps().parallelShaderCompile = parallelShaderCompile;\r\n    }\r\n\r\n    private _compute(mesh: AbstractMesh, effect: Effect): void {\r\n        const engine = this._engine as Engine;\r\n\r\n        // Buffer\r\n        let targetBuffer: Buffer;\r\n        const vertexCount = mesh.getTotalVertices();\r\n\r\n        if (!this._buffers[mesh.uniqueId]) {\r\n            const targetData = new Float32Array(vertexCount * 3);\r\n            targetBuffer = new Buffer(mesh.getEngine(), targetData, true, 3);\r\n            this._buffers[mesh.uniqueId] = targetBuffer;\r\n        } else {\r\n            targetBuffer = this._buffers[mesh.uniqueId];\r\n        }\r\n\r\n        // Bind\r\n        effect.getEngine().enableEffect(effect);\r\n        (mesh as Mesh)._bindDirect(effect, null, true);\r\n\r\n        // Bones\r\n        BindBonesParameters(mesh, effect);\r\n\r\n        // Morph targets\r\n        BindMorphTargetParameters(mesh, effect);\r\n        if (mesh.morphTargetManager && mesh.morphTargetManager.isUsingTextureForTargets) {\r\n            mesh.morphTargetManager._bind(effect);\r\n        }\r\n\r\n        // BVA\r\n        const bvaManager = (<Mesh>mesh).bakedVertexAnimationManager;\r\n\r\n        if (bvaManager && bvaManager.isEnabled) {\r\n            mesh.bakedVertexAnimationManager?.bind(effect, false);\r\n        }\r\n\r\n        // Update\r\n        const arrayBuffer = targetBuffer.getData()! as Float32Array;\r\n        engine.bindTransformFeedbackBuffer(targetBuffer.getBuffer());\r\n        engine.setRasterizerState(false);\r\n        engine.beginTransformFeedback(true);\r\n        engine.drawArraysType(Constants.MATERIAL_PointFillMode, 0, vertexCount);\r\n        engine.endTransformFeedback();\r\n        engine.setRasterizerState(true);\r\n        engine.readTransformFeedbackBuffer(arrayBuffer);\r\n        engine.bindTransformFeedbackBuffer(null);\r\n\r\n        // Update mesh\r\n        if (this._meshListCounter === 0) {\r\n            mesh._refreshBoundingInfo(arrayBuffer, null);\r\n        } else {\r\n            const bb = mesh.getBoundingInfo().boundingBox;\r\n            const extend = extractMinAndMax(arrayBuffer, 0, vertexCount);\r\n\r\n            TransformFeedbackBoundingHelper._Min.copyFrom(bb.minimum).minimizeInPlace(extend.minimum);\r\n            TransformFeedbackBoundingHelper._Max.copyFrom(bb.maximum).maximizeInPlace(extend.maximum);\r\n\r\n            mesh._refreshBoundingInfoDirect({ minimum: TransformFeedbackBoundingHelper._Min, maximum: TransformFeedbackBoundingHelper._Max });\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public registerMeshListAsync(meshes: AbstractMesh | AbstractMesh[]): Promise<void> {\r\n        if (!Array.isArray(meshes)) {\r\n            meshes = [meshes];\r\n        }\r\n\r\n        this._meshList = meshes;\r\n        this._meshListCounter = 0;\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /** @internal */\r\n    public processMeshList(): void {\r\n        if (this._meshList.length === 0) {\r\n            return;\r\n        }\r\n\r\n        this._processMeshList(this._meshList);\r\n        this._meshListCounter++;\r\n    }\r\n\r\n    /** @internal */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public fetchResultsForMeshListAsync(): Promise<void> {\r\n        this._meshListCounter = 0;\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose(): void {\r\n        for (const key in this._buffers) {\r\n            this._buffers[key].dispose();\r\n        }\r\n        this._buffers = {};\r\n        this._effects = {};\r\n        this._engine = null;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["name", "shader"]
}
