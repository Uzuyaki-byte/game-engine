import {
  BindBonesParameters,
  BindMorphTargetParameters,
  PrepareAttributesForBakedVertexAnimation,
  PrepareDefinesAndAttributesForMorphTargets
} from "./chunk-5DUM2KSL.js";
import {
  __decorate,
  nativeOverride
} from "./chunk-TZIM6IZC.js";
import {
  Vector3
} from "./chunk-7VMTUWKL.js";
import {
  Buffer,
  VertexBuffer
} from "./chunk-LAFJMI44.js";
import {
  ShaderStore
} from "./chunk-FX6MN5HL.js";

// node_modules/@babylonjs/core/Maths/math.functions.js
var MathHelpers = class {
  static extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, minimum, maximum) {
    for (let index = indexStart; index < indexStart + indexCount; index++) {
      const offset = indices[index] * 3;
      const x = positions[offset];
      const y = positions[offset + 1];
      const z = positions[offset + 2];
      minimum.minimizeInPlaceFromFloats(x, y, z);
      maximum.maximizeInPlaceFromFloats(x, y, z);
    }
  }
  static extractMinAndMax(positions, start, count, stride, minimum, maximum) {
    for (let index = start, offset = start * stride; index < start + count; index++, offset += stride) {
      const x = positions[offset];
      const y = positions[offset + 1];
      const z = positions[offset + 2];
      minimum.minimizeInPlaceFromFloats(x, y, z);
      maximum.maximizeInPlaceFromFloats(x, y, z);
    }
  }
};
__decorate([
  nativeOverride.filter((...[positions, indices]) => !Array.isArray(positions) && !Array.isArray(indices))
  // eslint-disable-next-line @typescript-eslint/naming-convention
], MathHelpers, "extractMinAndMaxIndexed", null);
__decorate([
  nativeOverride.filter((...[positions]) => !Array.isArray(positions))
  // eslint-disable-next-line @typescript-eslint/naming-convention
], MathHelpers, "extractMinAndMax", null);
function extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, bias = null) {
  const minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
  const maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
  MathHelpers.extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, minimum, maximum);
  if (bias) {
    minimum.x -= minimum.x * bias.x + bias.y;
    minimum.y -= minimum.y * bias.x + bias.y;
    minimum.z -= minimum.z * bias.x + bias.y;
    maximum.x += maximum.x * bias.x + bias.y;
    maximum.y += maximum.y * bias.x + bias.y;
    maximum.z += maximum.z * bias.x + bias.y;
  }
  return {
    minimum,
    maximum
  };
}
function extractMinAndMax(positions, start, count, bias = null, stride) {
  const minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
  const maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
  if (!stride) {
    stride = 3;
  }
  MathHelpers.extractMinAndMax(positions, start, count, stride, minimum, maximum);
  if (bias) {
    minimum.x -= minimum.x * bias.x + bias.y;
    minimum.y -= minimum.y * bias.x + bias.y;
    minimum.z -= minimum.z * bias.x + bias.y;
    maximum.x += maximum.x * bias.x + bias.y;
    maximum.y += maximum.y * bias.x + bias.y;
    maximum.z += maximum.z * bias.x + bias.y;
  }
  return {
    minimum,
    maximum
  };
}
function FixFlippedFaces(positions, indices) {
  const boundingInfo = extractMinAndMax(positions, 0, positions.length / 3);
  const inside = boundingInfo.maximum.subtract(boundingInfo.minimum).scale(0.5).add(boundingInfo.minimum);
  const tmpVectorA = new Vector3();
  const tmpVectorB = new Vector3();
  const tmpVectorC = new Vector3();
  const tmpVectorAB = new Vector3();
  const tmpVectorAC = new Vector3();
  const tmpVectorNormal = new Vector3();
  const tmpVectorAvgNormal = new Vector3();
  for (let index = 0; index < indices.length; index += 3) {
    const a = indices[index];
    const b = indices[index + 1];
    const c = indices[index + 2];
    tmpVectorA.fromArray(positions, a * 3);
    tmpVectorB.fromArray(positions, b * 3);
    tmpVectorC.fromArray(positions, c * 3);
    tmpVectorB.subtractToRef(tmpVectorA, tmpVectorAB);
    tmpVectorC.subtractToRef(tmpVectorA, tmpVectorAC);
    Vector3.CrossToRef(tmpVectorAB, tmpVectorAC, tmpVectorNormal);
    tmpVectorNormal.normalize();
    const avgX = tmpVectorA.x + tmpVectorB.x + tmpVectorC.x;
    const avgY = tmpVectorA.y + tmpVectorB.y + tmpVectorC.y;
    const avgZ = tmpVectorA.z + tmpVectorB.z + tmpVectorC.z;
    tmpVectorAvgNormal.set(avgX / 3, avgY / 3, avgZ / 3);
    tmpVectorAvgNormal.subtractInPlace(inside);
    tmpVectorAvgNormal.normalize();
    if (Vector3.Dot(tmpVectorNormal, tmpVectorAvgNormal) >= 0) {
      indices[index] = c;
      indices[index + 2] = a;
    }
  }
}

// node_modules/@babylonjs/core/Shaders/gpuTransform.vertex.js
var name = "gpuTransformVertexShader";
var shader = `attribute vec3 position;
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
out vec3 outPosition;const mat4 identity=mat4(
vec4(1.0,0.0,0.0,0.0),
vec4(0.0,1.0,0.0,0.0),
vec4(0.0,0.0,1.0,0.0),
vec4(0.0,0.0,0.0,1.0)
);void main(void) {vec3 positionUpdated=position;
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
mat4 finalWorld=identity;
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);outPosition=worldPos.xyz;}`;
if (!ShaderStore.ShadersStore[name]) {
  ShaderStore.ShadersStore[name] = shader;
}

// node_modules/@babylonjs/core/Shaders/gpuTransform.fragment.js
var name2 = "gpuTransformPixelShader";
var shader2 = `#version 300 es
void main() {discard;}
`;
if (!ShaderStore.ShadersStore[name2]) {
  ShaderStore.ShadersStore[name2] = shader2;
}

// node_modules/@babylonjs/core/Culling/Helper/transformFeedbackBoundingHelper.js
var TransformFeedbackBoundingHelper = class _TransformFeedbackBoundingHelper {
  /**
   * Creates a new TransformFeedbackBoundingHelper
   * @param engine defines the engine to use
   */
  constructor(engine) {
    this._buffers = {};
    this._effects = {};
    this._meshListCounter = 0;
    this._engine = engine;
  }
  /** @internal */
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  processAsync(meshes) {
    if (!Array.isArray(meshes)) {
      meshes = [meshes];
    }
    this._meshListCounter = 0;
    this._processMeshList(meshes);
    return Promise.resolve();
  }
  _processMeshList(meshes) {
    const parallelShaderCompile = this._engine.getCaps().parallelShaderCompile;
    this._engine.getCaps().parallelShaderCompile = void 0;
    for (let i = 0; i < meshes.length; ++i) {
      const mesh = meshes[i];
      const vertexCount = mesh.getTotalVertices();
      if (vertexCount === 0 || !mesh.getVertexBuffer || !mesh.getVertexBuffer(VertexBuffer.PositionKind)) {
        continue;
      }
      let computeEffect;
      const defines = [];
      const attribs = [VertexBuffer.PositionKind];
      if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
        attribs.push(VertexBuffer.MatricesIndicesKind);
        attribs.push(VertexBuffer.MatricesWeightsKind);
        if (mesh.numBoneInfluencers > 4) {
          attribs.push(VertexBuffer.MatricesIndicesExtraKind);
          attribs.push(VertexBuffer.MatricesWeightsExtraKind);
        }
        defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
        defines.push("#define BONETEXTURE " + mesh.skeleton.isUsingTextureForMatrices);
        defines.push("#define BonesPerMesh " + (mesh.skeleton.bones.length + 1));
      } else {
        defines.push("#define NUM_BONE_INFLUENCERS 0");
      }
      const numMorphInfluencers = mesh.morphTargetManager ? PrepareDefinesAndAttributesForMorphTargets(
        mesh.morphTargetManager,
        defines,
        attribs,
        mesh,
        true,
        // usePositionMorph
        false,
        // useNormalMorph
        false,
        // useTangentMorph
        false,
        // useUVMorph
        false,
        // useUV2Morph
        false
        // useColorMorph
      ) : 0;
      const bvaManager = mesh.bakedVertexAnimationManager;
      if (bvaManager && bvaManager.isEnabled) {
        defines.push("#define BAKED_VERTEX_ANIMATION_TEXTURE");
        PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);
      }
      const join = defines.join("\n");
      if (!this._effects[join]) {
        const uniforms = [
          "boneTextureWidth",
          "mBones",
          "morphTargetInfluences",
          "morphTargetCount",
          "morphTargetTextureInfo",
          "morphTargetTextureIndices",
          "bakedVertexAnimationSettings",
          "bakedVertexAnimationTextureSizeInverted",
          "bakedVertexAnimationTime"
        ];
        const samplers = ["boneSampler", "morphTargets", "bakedVertexAnimationTexture"];
        const computeEffectOptions = {
          attributes: attribs,
          uniformsNames: uniforms,
          uniformBuffersNames: [],
          samplers,
          defines: join,
          fallbacks: null,
          onCompiled: null,
          onError: null,
          indexParameters: { maxSimultaneousMorphTargets: numMorphInfluencers },
          maxSimultaneousLights: 0,
          transformFeedbackVaryings: ["outPosition"]
        };
        computeEffect = this._engine.createEffect("gpuTransform", computeEffectOptions, this._engine);
        this._effects[join] = computeEffect;
      } else {
        computeEffect = this._effects[join];
      }
      this._compute(mesh, computeEffect);
    }
    this._engine.getCaps().parallelShaderCompile = parallelShaderCompile;
  }
  _compute(mesh, effect) {
    const engine = this._engine;
    let targetBuffer;
    const vertexCount = mesh.getTotalVertices();
    if (!this._buffers[mesh.uniqueId]) {
      const targetData = new Float32Array(vertexCount * 3);
      targetBuffer = new Buffer(mesh.getEngine(), targetData, true, 3);
      this._buffers[mesh.uniqueId] = targetBuffer;
    } else {
      targetBuffer = this._buffers[mesh.uniqueId];
    }
    effect.getEngine().enableEffect(effect);
    mesh._bindDirect(effect, null, true);
    BindBonesParameters(mesh, effect);
    BindMorphTargetParameters(mesh, effect);
    if (mesh.morphTargetManager && mesh.morphTargetManager.isUsingTextureForTargets) {
      mesh.morphTargetManager._bind(effect);
    }
    const bvaManager = mesh.bakedVertexAnimationManager;
    if (bvaManager && bvaManager.isEnabled) {
      mesh.bakedVertexAnimationManager?.bind(effect, false);
    }
    const arrayBuffer = targetBuffer.getData();
    engine.bindTransformFeedbackBuffer(targetBuffer.getBuffer());
    engine.setRasterizerState(false);
    engine.beginTransformFeedback(true);
    engine.drawArraysType(2, 0, vertexCount);
    engine.endTransformFeedback();
    engine.setRasterizerState(true);
    engine.readTransformFeedbackBuffer(arrayBuffer);
    engine.bindTransformFeedbackBuffer(null);
    if (this._meshListCounter === 0) {
      mesh._refreshBoundingInfo(arrayBuffer, null);
    } else {
      const bb = mesh.getBoundingInfo().boundingBox;
      const extend = extractMinAndMax(arrayBuffer, 0, vertexCount);
      _TransformFeedbackBoundingHelper._Min.copyFrom(bb.minimum).minimizeInPlace(extend.minimum);
      _TransformFeedbackBoundingHelper._Max.copyFrom(bb.maximum).maximizeInPlace(extend.maximum);
      mesh._refreshBoundingInfoDirect({ minimum: _TransformFeedbackBoundingHelper._Min, maximum: _TransformFeedbackBoundingHelper._Max });
    }
  }
  /** @internal */
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  registerMeshListAsync(meshes) {
    if (!Array.isArray(meshes)) {
      meshes = [meshes];
    }
    this._meshList = meshes;
    this._meshListCounter = 0;
    return Promise.resolve();
  }
  /** @internal */
  processMeshList() {
    if (this._meshList.length === 0) {
      return;
    }
    this._processMeshList(this._meshList);
    this._meshListCounter++;
  }
  /** @internal */
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  fetchResultsForMeshListAsync() {
    this._meshListCounter = 0;
    return Promise.resolve();
  }
  /** @internal */
  dispose() {
    for (const key in this._buffers) {
      this._buffers[key].dispose();
    }
    this._buffers = {};
    this._effects = {};
    this._engine = null;
  }
};
TransformFeedbackBoundingHelper._Min = new Vector3();
TransformFeedbackBoundingHelper._Max = new Vector3();

export {
  extractMinAndMaxIndexed,
  extractMinAndMax,
  FixFlippedFaces,
  TransformFeedbackBoundingHelper
};
//# sourceMappingURL=chunk-KAK237JI.js.map
